Observer Pattern  觀察者模式
觀察者模式定義了物件之間的一對多關係，當一個物件改變狀態，其他相依者都會收到通知並自動被更新或適當的修改。
不需要每5秒檢查一次 或是1秒檢查一次，只需要等他通知後再去檢查。

目的：
讓Customer與Office降低耦合，使用雙方的抽像Class當做接口，不依賴具體Class。

實作：
Customer訂閱報紙時，將Customer加入報社ISubject中，當報社要通知大家時，從listObservers中的IObserver每個人發送通知。
listObservers可以存於ISubject中 也可存於NewspaperOffice中，這樣就可由Customer通知大家，因為他已有私有的ISubject。
Customer也可儲存NewspaperOffice的資料於Customer中，視需求而定，但不影響觀察者模式的架構。
其精神主要為NewspaperOffice通知listObservers中的每個Customer，且主程式不需更改，只需調整listObservers中的Customer數量，和增加Customer的Update實作。

用途：
發送通知時、股票漲跌通知、按鈕按下 找按鈕要去做什麼實作功能、滑鼠按下 通知滑鼠事件 判斷哪個功能要執行
當其中一個物件的變更會影響其他物件，卻又不知道多少物件必須被同時變更時。
MVC(Model/View/Controller)是Observer的一個實例：
Subject就是Model，而Customer就是View，Controller充當兩者之間的中介者(Mediator)。
當Model的數據發生改變時，View將自動改變其顯示內容。

範例：
電子商務網站可以在執行發送操作後給用戶多個發送商品打折信息
某團隊戰鬥遊戲中某隊友犧牲將給所有成員提示


缺點：
如果有很多Customer的話，將所有的Customer都通知到會花費很多時間。